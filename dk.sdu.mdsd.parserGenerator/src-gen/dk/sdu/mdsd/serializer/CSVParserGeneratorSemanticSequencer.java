/*
 * generated by Xtext 2.21.0
 */
package dk.sdu.mdsd.serializer;

import com.google.inject.Inject;
import dk.sdu.mdsd.cSVParserGenerator.Add;
import dk.sdu.mdsd.cSVParserGenerator.And;
import dk.sdu.mdsd.cSVParserGenerator.CSVParserGeneratorPackage;
import dk.sdu.mdsd.cSVParserGenerator.ColAct;
import dk.sdu.mdsd.cSVParserGenerator.ColDecl;
import dk.sdu.mdsd.cSVParserGenerator.ColumnVar;
import dk.sdu.mdsd.cSVParserGenerator.Constrain;
import dk.sdu.mdsd.cSVParserGenerator.Constraint;
import dk.sdu.mdsd.cSVParserGenerator.Date;
import dk.sdu.mdsd.cSVParserGenerator.DateLit;
import dk.sdu.mdsd.cSVParserGenerator.Div;
import dk.sdu.mdsd.cSVParserGenerator.Equ;
import dk.sdu.mdsd.cSVParserGenerator.Ext;
import dk.sdu.mdsd.cSVParserGenerator.External;
import dk.sdu.mdsd.cSVParserGenerator.FileDecl;
import dk.sdu.mdsd.cSVParserGenerator.Floa;
import dk.sdu.mdsd.cSVParserGenerator.Geq;
import dk.sdu.mdsd.cSVParserGenerator.Gt;
import dk.sdu.mdsd.cSVParserGenerator.Integ;
import dk.sdu.mdsd.cSVParserGenerator.Leq;
import dk.sdu.mdsd.cSVParserGenerator.Lt;
import dk.sdu.mdsd.cSVParserGenerator.Max;
import dk.sdu.mdsd.cSVParserGenerator.Mean;
import dk.sdu.mdsd.cSVParserGenerator.Min;
import dk.sdu.mdsd.cSVParserGenerator.Minus;
import dk.sdu.mdsd.cSVParserGenerator.Mult;
import dk.sdu.mdsd.cSVParserGenerator.Neq;
import dk.sdu.mdsd.cSVParserGenerator.Num;
import dk.sdu.mdsd.cSVParserGenerator.Or;
import dk.sdu.mdsd.cSVParserGenerator.Output;
import dk.sdu.mdsd.cSVParserGenerator.Parens;
import dk.sdu.mdsd.cSVParserGenerator.Parser;
import dk.sdu.mdsd.cSVParserGenerator.Plus;
import dk.sdu.mdsd.cSVParserGenerator.Rem;
import dk.sdu.mdsd.cSVParserGenerator.Stat;
import dk.sdu.mdsd.cSVParserGenerator.Std;
import dk.sdu.mdsd.cSVParserGenerator.Str;
import dk.sdu.mdsd.cSVParserGenerator.StringLit;
import dk.sdu.mdsd.cSVParserGenerator.SumFunc;
import dk.sdu.mdsd.cSVParserGenerator.ValueM;
import dk.sdu.mdsd.cSVParserGenerator.ValueMod;
import dk.sdu.mdsd.services.CSVParserGeneratorGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CSVParserGeneratorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CSVParserGeneratorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CSVParserGeneratorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CSVParserGeneratorPackage.ADD:
				sequence_ColumnAction(context, (Add) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.AND:
				sequence_LogExp(context, (And) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.COL_ACT:
				sequence_Modification(context, (ColAct) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.COL_DECL:
				sequence_ColDecl(context, (ColDecl) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.COLUMN_VAR:
				sequence_ColumnVar(context, (ColumnVar) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.CONSTRAIN:
				sequence_Modification(context, (Constrain) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.DATE:
				sequence_Type(context, (Date) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.DATE_LIT:
				sequence_DateLiteral(context, (DateLit) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.DIV:
				sequence_Factor(context, (Div) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.EQU:
				sequence_Comparison(context, (Equ) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.EXT:
				sequence_Modification(context, (Ext) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.EXTERNAL:
				sequence_External(context, (External) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.FILE_DECL:
				sequence_FileDecl(context, (FileDecl) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.FLOA:
				sequence_Type(context, (Floa) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.GEQ:
				sequence_Comparison(context, (Geq) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.GT:
				sequence_Comparison(context, (Gt) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.INTEG:
				sequence_Type(context, (Integ) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.LEQ:
				sequence_Comparison(context, (Leq) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.LT:
				sequence_Comparison(context, (Lt) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.MAX:
				sequence_StatFunc(context, (Max) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.MEAN:
				sequence_StatFunc(context, (Mean) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.MIN:
				sequence_StatFunc(context, (Min) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.MINUS:
				sequence_Sum(context, (Minus) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.MULT:
				sequence_Factor(context, (Mult) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.NEQ:
				sequence_Comparison(context, (Neq) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.NUM:
				sequence_Number(context, (Num) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.OR:
				sequence_LogExp(context, (Or) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.PARENS:
				sequence_Parens(context, (Parens) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.PARSER:
				sequence_Parser(context, (Parser) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.PLUS:
				sequence_Sum(context, (Plus) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.REM:
				sequence_ColumnAction(context, (Rem) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.STAT:
				sequence_Modification(context, (Stat) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.STD:
				sequence_StatFunc(context, (Std) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.STR:
				sequence_Type(context, (Str) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.STRING_LIT:
				sequence_StringLiteral(context, (StringLit) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.SUM_FUNC:
				sequence_StatFunc(context, (SumFunc) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.VALUE_M:
				sequence_Modification(context, (ValueM) semanticObject); 
				return; 
			case CSVParserGeneratorPackage.VALUE_MOD:
				sequence_ValueMod(context, (ValueMod) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ColDecl returns ColDecl
	 *
	 * Constraint:
	 *     (name=ID type=Type mods+=Modification*)
	 */
	protected void sequence_ColDecl(ISerializationContext context, ColDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnAction returns Add
	 *
	 * Constraint:
	 *     (name=ID type=Type mod=LogExp)
	 */
	protected void sequence_ColumnAction(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.ADD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.ADD__NAME));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.ADD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.ADD__TYPE));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.ADD__MOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.ADD__MOD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnActionAccess().getNameIDTerminalRuleCall_0_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getColumnActionAccess().getTypeTypeParserRuleCall_0_4_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getColumnActionAccess().getModLogExpParserRuleCall_0_6_0(), semanticObject.getMod());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColumnAction returns Rem
	 *
	 * Constraint:
	 *     name=[ColDecl|ID]
	 */
	protected void sequence_ColumnAction(ISerializationContext context, Rem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.REM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.REM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnActionAccess().getNameColDeclIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.REM__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns ColumnVar
	 *     LogExp.Or_1_0_0_1 returns ColumnVar
	 *     LogExp.And_1_0_1_1 returns ColumnVar
	 *     Comparison returns ColumnVar
	 *     Comparison.Lt_1_0_0_1 returns ColumnVar
	 *     Comparison.Gt_1_0_1_1 returns ColumnVar
	 *     Comparison.Equ_1_0_2_1 returns ColumnVar
	 *     Comparison.Neq_1_0_3_1 returns ColumnVar
	 *     Comparison.Leq_1_0_4_1 returns ColumnVar
	 *     Comparison.Geq_1_0_5_1 returns ColumnVar
	 *     Sum returns ColumnVar
	 *     Sum.Plus_1_0_0_1 returns ColumnVar
	 *     Sum.Minus_1_0_1_1 returns ColumnVar
	 *     Factor returns ColumnVar
	 *     Factor.Mult_1_0_0_1 returns ColumnVar
	 *     Factor.Div_1_0_1_1 returns ColumnVar
	 *     Primary returns ColumnVar
	 *     ColumnVar returns ColumnVar
	 *
	 * Constraint:
	 *     name=[ColDecl|ID]
	 */
	protected void sequence_ColumnVar(ISerializationContext context, ColumnVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.COLUMN_VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.COLUMN_VAR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnVarAccess().getNameColDeclIDTerminalRuleCall_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.COLUMN_VAR__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Equ
	 *     LogExp.Or_1_0_0_1 returns Equ
	 *     LogExp.And_1_0_1_1 returns Equ
	 *     Comparison returns Equ
	 *     Comparison.Lt_1_0_0_1 returns Equ
	 *     Comparison.Gt_1_0_1_1 returns Equ
	 *     Comparison.Equ_1_0_2_1 returns Equ
	 *     Comparison.Neq_1_0_3_1 returns Equ
	 *     Comparison.Leq_1_0_4_1 returns Equ
	 *     Comparison.Geq_1_0_5_1 returns Equ
	 *
	 * Constraint:
	 *     (left=Comparison_Equ_1_0_2_1 right=Sum)
	 */
	protected void sequence_Comparison(ISerializationContext context, Equ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.EQU__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.EQU__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.EQU__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.EQU__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getEquLeftAction_1_0_2_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightSumParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Geq
	 *     LogExp.Or_1_0_0_1 returns Geq
	 *     LogExp.And_1_0_1_1 returns Geq
	 *     Comparison returns Geq
	 *     Comparison.Lt_1_0_0_1 returns Geq
	 *     Comparison.Gt_1_0_1_1 returns Geq
	 *     Comparison.Equ_1_0_2_1 returns Geq
	 *     Comparison.Neq_1_0_3_1 returns Geq
	 *     Comparison.Leq_1_0_4_1 returns Geq
	 *     Comparison.Geq_1_0_5_1 returns Geq
	 *
	 * Constraint:
	 *     (left=Comparison_Geq_1_0_5_1 right=Sum)
	 */
	protected void sequence_Comparison(ISerializationContext context, Geq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.GEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.GEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.GEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.GEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGeqLeftAction_1_0_5_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightSumParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Gt
	 *     LogExp.Or_1_0_0_1 returns Gt
	 *     LogExp.And_1_0_1_1 returns Gt
	 *     Comparison returns Gt
	 *     Comparison.Lt_1_0_0_1 returns Gt
	 *     Comparison.Gt_1_0_1_1 returns Gt
	 *     Comparison.Equ_1_0_2_1 returns Gt
	 *     Comparison.Neq_1_0_3_1 returns Gt
	 *     Comparison.Leq_1_0_4_1 returns Gt
	 *     Comparison.Geq_1_0_5_1 returns Gt
	 *
	 * Constraint:
	 *     (left=Comparison_Gt_1_0_1_1 right=Sum)
	 */
	protected void sequence_Comparison(ISerializationContext context, Gt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.GT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.GT__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.GT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.GT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGtLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightSumParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Leq
	 *     LogExp.Or_1_0_0_1 returns Leq
	 *     LogExp.And_1_0_1_1 returns Leq
	 *     Comparison returns Leq
	 *     Comparison.Lt_1_0_0_1 returns Leq
	 *     Comparison.Gt_1_0_1_1 returns Leq
	 *     Comparison.Equ_1_0_2_1 returns Leq
	 *     Comparison.Neq_1_0_3_1 returns Leq
	 *     Comparison.Leq_1_0_4_1 returns Leq
	 *     Comparison.Geq_1_0_5_1 returns Leq
	 *
	 * Constraint:
	 *     (left=Comparison_Leq_1_0_4_1 right=Sum)
	 */
	protected void sequence_Comparison(ISerializationContext context, Leq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.LEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.LEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.LEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.LEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLeqLeftAction_1_0_4_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightSumParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Lt
	 *     LogExp.Or_1_0_0_1 returns Lt
	 *     LogExp.And_1_0_1_1 returns Lt
	 *     Comparison returns Lt
	 *     Comparison.Lt_1_0_0_1 returns Lt
	 *     Comparison.Gt_1_0_1_1 returns Lt
	 *     Comparison.Equ_1_0_2_1 returns Lt
	 *     Comparison.Neq_1_0_3_1 returns Lt
	 *     Comparison.Leq_1_0_4_1 returns Lt
	 *     Comparison.Geq_1_0_5_1 returns Lt
	 *
	 * Constraint:
	 *     (left=Comparison_Lt_1_0_0_1 right=Sum)
	 */
	protected void sequence_Comparison(ISerializationContext context, Lt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.LT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.LT__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.LT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.LT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLtLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightSumParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Neq
	 *     LogExp.Or_1_0_0_1 returns Neq
	 *     LogExp.And_1_0_1_1 returns Neq
	 *     Comparison returns Neq
	 *     Comparison.Lt_1_0_0_1 returns Neq
	 *     Comparison.Gt_1_0_1_1 returns Neq
	 *     Comparison.Equ_1_0_2_1 returns Neq
	 *     Comparison.Neq_1_0_3_1 returns Neq
	 *     Comparison.Leq_1_0_4_1 returns Neq
	 *     Comparison.Geq_1_0_5_1 returns Neq
	 *
	 * Constraint:
	 *     (left=Comparison_Neq_1_0_3_1 right=Sum)
	 */
	protected void sequence_Comparison(ISerializationContext context, Neq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.NEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.NEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.NEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.NEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getNeqLeftAction_1_0_3_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightSumParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=[ColDecl|ID] exp=LogExp)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.CONSTRAINT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.CONSTRAINT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getNameColDeclIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.CONSTRAINT__NAME, false));
		feeder.accept(grammarAccess.getConstraintAccess().getExpLogExpParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns DateLit
	 *     LogExp.Or_1_0_0_1 returns DateLit
	 *     LogExp.And_1_0_1_1 returns DateLit
	 *     Comparison returns DateLit
	 *     Comparison.Lt_1_0_0_1 returns DateLit
	 *     Comparison.Gt_1_0_1_1 returns DateLit
	 *     Comparison.Equ_1_0_2_1 returns DateLit
	 *     Comparison.Neq_1_0_3_1 returns DateLit
	 *     Comparison.Leq_1_0_4_1 returns DateLit
	 *     Comparison.Geq_1_0_5_1 returns DateLit
	 *     Sum returns DateLit
	 *     Sum.Plus_1_0_0_1 returns DateLit
	 *     Sum.Minus_1_0_1_1 returns DateLit
	 *     Factor returns DateLit
	 *     Factor.Mult_1_0_0_1 returns DateLit
	 *     Factor.Div_1_0_1_1 returns DateLit
	 *     Primary returns DateLit
	 *     DateLiteral returns DateLit
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_DateLiteral(ISerializationContext context, DateLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.DATE_LIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.DATE_LIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateLiteralAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     External returns External
	 *
	 * Constraint:
	 *     (name=ID inp=[ColDecl|ID])
	 */
	protected void sequence_External(ISerializationContext context, External semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.EXTERNAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.EXTERNAL__NAME));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.EXTERNAL__INP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.EXTERNAL__INP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternalAccess().getInpColDeclIDTerminalRuleCall_3_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.EXTERNAL__INP, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Div
	 *     LogExp.Or_1_0_0_1 returns Div
	 *     LogExp.And_1_0_1_1 returns Div
	 *     Comparison returns Div
	 *     Comparison.Lt_1_0_0_1 returns Div
	 *     Comparison.Gt_1_0_1_1 returns Div
	 *     Comparison.Equ_1_0_2_1 returns Div
	 *     Comparison.Neq_1_0_3_1 returns Div
	 *     Comparison.Leq_1_0_4_1 returns Div
	 *     Comparison.Geq_1_0_5_1 returns Div
	 *     Sum returns Div
	 *     Sum.Plus_1_0_0_1 returns Div
	 *     Sum.Minus_1_0_1_1 returns Div
	 *     Factor returns Div
	 *     Factor.Mult_1_0_0_1 returns Div
	 *     Factor.Div_1_0_1_1 returns Div
	 *
	 * Constraint:
	 *     (left=Factor_Div_1_0_1_1 right=Primary)
	 */
	protected void sequence_Factor(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getDivLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Mult
	 *     LogExp.Or_1_0_0_1 returns Mult
	 *     LogExp.And_1_0_1_1 returns Mult
	 *     Comparison returns Mult
	 *     Comparison.Lt_1_0_0_1 returns Mult
	 *     Comparison.Gt_1_0_1_1 returns Mult
	 *     Comparison.Equ_1_0_2_1 returns Mult
	 *     Comparison.Neq_1_0_3_1 returns Mult
	 *     Comparison.Leq_1_0_4_1 returns Mult
	 *     Comparison.Geq_1_0_5_1 returns Mult
	 *     Sum returns Mult
	 *     Sum.Plus_1_0_0_1 returns Mult
	 *     Sum.Minus_1_0_1_1 returns Mult
	 *     Factor returns Mult
	 *     Factor.Mult_1_0_0_1 returns Mult
	 *     Factor.Div_1_0_1_1 returns Mult
	 *
	 * Constraint:
	 *     (left=Factor_Mult_1_0_0_1 right=Primary)
	 */
	protected void sequence_Factor(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.MULT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.MULT__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.MULT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.MULT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getMultLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FileDecl returns FileDecl
	 *
	 * Constraint:
	 *     (name=STRING sepchar=STRING)
	 */
	protected void sequence_FileDecl(ISerializationContext context, FileDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.FILE_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.FILE_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.FILE_DECL__SEPCHAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.FILE_DECL__SEPCHAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileDeclAccess().getNameSTRINGTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFileDeclAccess().getSepcharSTRINGTerminalRuleCall_4_0(), semanticObject.getSepchar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns And
	 *     LogExp.Or_1_0_0_1 returns And
	 *     LogExp.And_1_0_1_1 returns And
	 *
	 * Constraint:
	 *     (left=LogExp_And_1_0_1_1 right=Comparison)
	 */
	protected void sequence_LogExp(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogExpAccess().getAndLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogExpAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Or
	 *     LogExp.Or_1_0_0_1 returns Or
	 *     LogExp.And_1_0_1_1 returns Or
	 *
	 * Constraint:
	 *     (left=LogExp_Or_1_0_0_1 right=Comparison)
	 */
	protected void sequence_LogExp(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogExpAccess().getOrLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogExpAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Modification returns ColAct
	 *
	 * Constraint:
	 *     mods+=ColumnAction*
	 */
	protected void sequence_Modification(ISerializationContext context, ColAct semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modification returns Constrain
	 *
	 * Constraint:
	 *     mods+=Constraint*
	 */
	protected void sequence_Modification(ISerializationContext context, Constrain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modification returns Ext
	 *
	 * Constraint:
	 *     mods+=External*
	 */
	protected void sequence_Modification(ISerializationContext context, Ext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modification returns Stat
	 *
	 * Constraint:
	 *     mods+=StatFunc*
	 */
	protected void sequence_Modification(ISerializationContext context, Stat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modification returns ValueM
	 *
	 * Constraint:
	 *     mods+=ValueMod*
	 */
	protected void sequence_Modification(ISerializationContext context, ValueM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Num
	 *     LogExp.Or_1_0_0_1 returns Num
	 *     LogExp.And_1_0_1_1 returns Num
	 *     Comparison returns Num
	 *     Comparison.Lt_1_0_0_1 returns Num
	 *     Comparison.Gt_1_0_1_1 returns Num
	 *     Comparison.Equ_1_0_2_1 returns Num
	 *     Comparison.Neq_1_0_3_1 returns Num
	 *     Comparison.Leq_1_0_4_1 returns Num
	 *     Comparison.Geq_1_0_5_1 returns Num
	 *     Sum returns Num
	 *     Sum.Plus_1_0_0_1 returns Num
	 *     Sum.Minus_1_0_1_1 returns Num
	 *     Factor returns Num
	 *     Factor.Mult_1_0_0_1 returns Num
	 *     Factor.Div_1_0_1_1 returns Num
	 *     Primary returns Num
	 *     Number returns Num
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Number(ISerializationContext context, Num semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.NUM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.NUM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (name=STRING number=INT?)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Parens
	 *     LogExp.Or_1_0_0_1 returns Parens
	 *     LogExp.And_1_0_1_1 returns Parens
	 *     Comparison returns Parens
	 *     Comparison.Lt_1_0_0_1 returns Parens
	 *     Comparison.Gt_1_0_1_1 returns Parens
	 *     Comparison.Equ_1_0_2_1 returns Parens
	 *     Comparison.Neq_1_0_3_1 returns Parens
	 *     Comparison.Leq_1_0_4_1 returns Parens
	 *     Comparison.Geq_1_0_5_1 returns Parens
	 *     Parens returns Parens
	 *     Sum returns Parens
	 *     Sum.Plus_1_0_0_1 returns Parens
	 *     Sum.Minus_1_0_1_1 returns Parens
	 *     Factor returns Parens
	 *     Factor.Mult_1_0_0_1 returns Parens
	 *     Factor.Div_1_0_1_1 returns Parens
	 *     Primary returns Parens
	 *
	 * Constraint:
	 *     exp=LogExp
	 */
	protected void sequence_Parens(ISerializationContext context, Parens semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.PARENS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.PARENS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParensAccess().getExpLogExpParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parser returns Parser
	 *
	 * Constraint:
	 *     (file=FileDecl? columns+=ColDecl+ mods+=Modification* out=Output?)
	 */
	protected void sequence_Parser(ISerializationContext context, Parser semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatFunc returns Max
	 *
	 * Constraint:
	 *     input=[ColDecl|ID]
	 */
	protected void sequence_StatFunc(ISerializationContext context, Max semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatFuncAccess().getInputColDeclIDTerminalRuleCall_0_3_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatFunc returns Mean
	 *
	 * Constraint:
	 *     input=[ColDecl|ID]
	 */
	protected void sequence_StatFunc(ISerializationContext context, Mean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatFuncAccess().getInputColDeclIDTerminalRuleCall_4_3_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatFunc returns Min
	 *
	 * Constraint:
	 *     input=[ColDecl|ID]
	 */
	protected void sequence_StatFunc(ISerializationContext context, Min semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatFuncAccess().getInputColDeclIDTerminalRuleCall_1_3_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatFunc returns Std
	 *
	 * Constraint:
	 *     input=[ColDecl|ID]
	 */
	protected void sequence_StatFunc(ISerializationContext context, Std semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatFuncAccess().getInputColDeclIDTerminalRuleCall_2_3_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatFunc returns SumFunc
	 *
	 * Constraint:
	 *     input=[ColDecl|ID]
	 */
	protected void sequence_StatFunc(ISerializationContext context, SumFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatFuncAccess().getInputColDeclIDTerminalRuleCall_3_3_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.STAT_FUNC__INPUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns StringLit
	 *     LogExp.Or_1_0_0_1 returns StringLit
	 *     LogExp.And_1_0_1_1 returns StringLit
	 *     Comparison returns StringLit
	 *     Comparison.Lt_1_0_0_1 returns StringLit
	 *     Comparison.Gt_1_0_1_1 returns StringLit
	 *     Comparison.Equ_1_0_2_1 returns StringLit
	 *     Comparison.Neq_1_0_3_1 returns StringLit
	 *     Comparison.Leq_1_0_4_1 returns StringLit
	 *     Comparison.Geq_1_0_5_1 returns StringLit
	 *     Sum returns StringLit
	 *     Sum.Plus_1_0_0_1 returns StringLit
	 *     Sum.Minus_1_0_1_1 returns StringLit
	 *     Factor returns StringLit
	 *     Factor.Mult_1_0_0_1 returns StringLit
	 *     Factor.Div_1_0_1_1 returns StringLit
	 *     Primary returns StringLit
	 *     StringLiteral returns StringLit
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.STRING_LIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.STRING_LIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Minus
	 *     LogExp.Or_1_0_0_1 returns Minus
	 *     LogExp.And_1_0_1_1 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Lt_1_0_0_1 returns Minus
	 *     Comparison.Gt_1_0_1_1 returns Minus
	 *     Comparison.Equ_1_0_2_1 returns Minus
	 *     Comparison.Neq_1_0_3_1 returns Minus
	 *     Comparison.Leq_1_0_4_1 returns Minus
	 *     Comparison.Geq_1_0_5_1 returns Minus
	 *     Sum returns Minus
	 *     Sum.Plus_1_0_0_1 returns Minus
	 *     Sum.Minus_1_0_1_1 returns Minus
	 *
	 * Constraint:
	 *     (left=Sum_Minus_1_0_1_1 right=Factor)
	 */
	protected void sequence_Sum(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getMinusLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogExp returns Plus
	 *     LogExp.Or_1_0_0_1 returns Plus
	 *     LogExp.And_1_0_1_1 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Lt_1_0_0_1 returns Plus
	 *     Comparison.Gt_1_0_1_1 returns Plus
	 *     Comparison.Equ_1_0_2_1 returns Plus
	 *     Comparison.Neq_1_0_3_1 returns Plus
	 *     Comparison.Leq_1_0_4_1 returns Plus
	 *     Comparison.Geq_1_0_5_1 returns Plus
	 *     Sum returns Plus
	 *     Sum.Plus_1_0_0_1 returns Plus
	 *     Sum.Minus_1_0_1_1 returns Plus
	 *
	 * Constraint:
	 *     (left=Sum_Plus_1_0_0_1 right=Factor)
	 */
	protected void sequence_Sum(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getPlusLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Date
	 *
	 * Constraint:
	 *     {Date}
	 */
	protected void sequence_Type(ISerializationContext context, Date semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Floa
	 *
	 * Constraint:
	 *     {Floa}
	 */
	protected void sequence_Type(ISerializationContext context, Floa semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Integ
	 *
	 * Constraint:
	 *     {Integ}
	 */
	protected void sequence_Type(ISerializationContext context, Integ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Str
	 *
	 * Constraint:
	 *     {Str}
	 */
	protected void sequence_Type(ISerializationContext context, Str semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueMod returns ValueMod
	 *
	 * Constraint:
	 *     (name=[ColDecl|ID] exp=LogExp)
	 */
	protected void sequence_ValueMod(ISerializationContext context, ValueMod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.VALUE_MOD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.VALUE_MOD__NAME));
			if (transientValues.isValueTransient(semanticObject, CSVParserGeneratorPackage.Literals.VALUE_MOD__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CSVParserGeneratorPackage.Literals.VALUE_MOD__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueModAccess().getNameColDeclIDTerminalRuleCall_0_0_1(), semanticObject.eGet(CSVParserGeneratorPackage.Literals.VALUE_MOD__NAME, false));
		feeder.accept(grammarAccess.getValueModAccess().getExpLogExpParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
}
